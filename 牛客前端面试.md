[HTML5技术](https://www.techug.com/post/40-important-html-5-interview-questions-with-answers.html)

# 前端基础



## HTTP



### HTTP和HTTPS

- HTTP，超文本传输协议，用于服务器端传输超文本到浏览器端

- HTTPS，在HTTP基础下加入了ssl层，确保了数据加密传输和身份认证，可以理解成HTTP的安全版

- HTTP和HTTPS对比：

  - HTTP传输的数据是未加密的明文；而HTTPS加入了SSL层，能进行身份验证、对传输的数据进行加密、使数据不被窃取改变保证完整性，更安全
  - 使用HTTPS的网站在搜索引擎上排名更高，而使用HTTP的网站可能会被标记为不安全
  - HTTP协议的端口是80；HTTPS协议的端口是443
  - 与HTTP相比，HTTPS需要ca证书，费用较高
  - HTTPS握手阶段比较费时， 会使页面加载时间延长
  - HTTPS缓存不如 HTTP高效， 会增加数据开销
  - SSL 证书需要绑定 IP， 不能再同一个 ip 上绑定多个域名， ipv4 资源支持不了这种消耗

- HTTPS工作原理：

  [参考资料：漫画聊HTTPS协议](https://zhuanlan.zhihu.com/p/57142784)

  [其他方法的不足](https://zhuanlan.zhihu.com/p/27395037)

  - 服务器端生成一对公钥和私钥，将公钥发给证书颁发机构

  - 证书机构用自己的私钥加密服务器端发送来的公钥，并利用服务端网址等信息生成证书签名，签名也经私钥加密。最后将证书发送给服务器端

  - 服务器端 直接发送给证书 客户端

  - 因为各大浏览器和操作系统有所有权威证书机构的名称和公钥，所以客户端可以根据机构名取出对应的机构公钥

  - 客户端先用公钥 解密出 证书签名，验证证书签名

  - 客户端再用机构公钥 解密 机构私钥，得到服务器端的公钥

  - 客户端对称生成密钥，用服务器端公钥加密该密钥，发送给服务器

  - 服务器端 用自己的私钥 解密 公钥，得到客户端的密钥，从此之后的数据传输就用该密钥加密解密

    （上述认证过程是在SSL层中完成的，现在的TSL是SSL的升级版）



### 说一下HTTP2.0

[一篇文章让你入门HTTP2](https://segmentfault.com/a/1190000016656529?utm_source=tag-newest)

- 多路复用

  允许通过一个http连接同时发送多个请求-响应消息，解决了浏览器限制同一个域名下的请求数量的问题

- 二进制分帧

  在应用层和传输层之间增加一个二进制分帧层，将传输信息分割成更小的帧，并进行二进制编码

- 首部压缩

  采用HPACK算法对首部进行编码，减少了首部大小（原来是文本形式的首部，加上cookie则更大）

- 服务器端推送

  服务器对客户端的一个请求发送多个响应（收到客户端的某个请求后主动推送其他资源）

- 更安全



### UDP和TCP区别

- TCP是面向连接的；UDP是无连接的
- TCP提供可靠的服务，通过TCP链接传送的数据，无差错、不丢失、不重复、按序到达；UDP不保证可靠交付
- TCP面向字节流；UDP面向字节流
- TCP只能一对一通信；UDP支持一对一，一对多
- TCP动态改变窗口的大小进行拥塞控制；UDP没有用塞控制(适合视频电话等需要源主机以恒定速率传输数据又允许丢包的应用)
- TCP首部最大20字节；UDP首部最大8字节



### TCP握手

[三次握手四次挥手](https://juejin.im/post/5b1d34eb6fb9a01e7d5c3e25#comment)

一句话概括：客户端和服务端都需要知道各自可收发， 因此需要三次握手

- 第一次握手(SYN=1，seqNum=X)：

  客户端发送一个SYN标志位置1的包，并产生随机的X放在序列号字段中，发起连接请求，等待服务器确认，进入```SYN_SEND```状态

- 第二次握手(SYN=1，ACK=1，seqNUm=Y，ackNum=X+1)：

  服务端发送一个SYN和ACK标志位都置1的确认包，（并将客户端序列号字段中的X+1存入确认号字段，随机产生Y存入序列号字段中），进入```SYN_RCVD```状态

- 第三次握手(ACK=1，ackNum=Y+1)

  客户端发送一个ACK标志位置1的确认包，并将服务端的序列号Y+1存入确认号字段中，进入```ESTABLISHED```状态

  当服务端接收到确认包后，握手结束，建立了TCP连接



### WebSocket的实现与应用

（一些概念：无状态、短连接、长连接、轮询、长轮询、http keep-alive、tcp keep-alive 心跳包  [参考资料1](WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎 https://www.zhihu.com/question/20215561/answer/40316953)  [参考资料2](https://juejin.im/post/5b10b822e51d4506cd4fc218 )）

WebSocket的特点是，服务器能主动发送数据给客户端，还有持久连接

实现：

①

握手建立连接的过程，与http协议差不多，只是请求头和响应头多了一些内容。

请求头的：

```Upgrade: websocket``` 和 ```Connection: Upgrade``` 告诉服务端发起的是websocket请求

```Sec-WebSocket-Key``` 是客户端随机生成的一个密钥 ，要求服务端必须返回一个对应加密的```Sec-WebSocket-Accept```应答

```Sec-WebSocket-Version```告诉服务器所使用的 Websocket 协议版本响应头的

响应头的：

```Upgrade: websocket``` 和 ```Connection: Upgrade``` 告诉客户端即将升级的是WebSocket协议（返回状态吗101）

② [websocket数据传输原理](https://cloud.tencent.com/developer/article/1194146 )  [websocket-protocol书](https://github.com/zhangkaitao/websocket-protocol)

数据传输以数据帧为单位，发送端将消息切割成多个帧发送，当标志位FIN=1时，表示是消息的最后一个分片，接收端将帧重组成消息，根据opCode标志位来对消息进行不同操作



### ❤❤❤HTTP请求方式

[请求报文格式](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html)

- http1.0：get、post、head
- http1.1：put、options、trace、delete、connection
- http2.0：patch



### ❤❤❤讲讲 304





### 301 和 302 的区别

- 301，永久移动。请求的资源被永久移动到新的url了，返回信息包含新的url，浏览器自动定向到新url





### ❤❤❤http 常用请求头





### 一个图片 url 访问后直接下载怎样实现

设置响应头：

```json
'Content-Disposition':'attachment;filename=xxx',
'Content-Type':'content-type: application/octet-stream' // 告诉客户端这是一个二进制文件
```



### fetch 发送 2 次请求的原因

[HTTP访问控制（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)

[跨源请求](https://zh.javascript.info/fetch-crossorigin)

[预检](https://www.w3cways.com/2280.html)

[跨域资源共享 CORS 详解](https://www.ruanyifeng.com/blog/2016/04/cors.html)

[简单请求非简单请求](https://juejin.im/post/5d71d1e7f265da03934c027b#comment)

**是浏览器CORS机制造成的。**

**当该请求是非简单请求时，就会触发浏览器首先会发送一个options预检请求，验证是否是服务器对跨源请求所支持 HTTP 方法，如果支持则状态码是204（no content）**

**然后在第二次中发送真正的请求**

简单请求：（普通 HTML Form 在不依赖脚本的情况下可以发出的请求）

①GET、HEAD、POST	

②没有自定义头，请求头的字段只能有Content-Type、Content-Language、Accept、Accept-Language等	

③Content-Type只能是application/x-www-form-urlencoded, multipart/form-data, text/plain

非简单请求：可能会对服务器数据产生副作用



### Cookie、 sessionStorage、 localStorage

[XXS攻击](https://segmentfault.com/a/1190000016551188)

- Cookie：存在于http头中在服务器和浏览器之间来回传送，可以自己设置过期时间，存储容量小只有4KB

  保存登录状态、保存用户页面设置信息、跟踪用户的行为(所选地区)

- sessionStorage：保存在客户端不参与与服务器通信，仅在当前窗口关闭前有效(刷新页面不会消失)，存储容量有5MB

- localStorage：保存在客户端不参与与服务器通信，除非人为清除不然不会失效同源窗口都可以共享数据， 存储容量有5MB

  编辑页面自动保存草稿功能



### Cookie 如何防范 XSS 攻击

[美团总结](https://juejin.im/post/5bad9140e51d450e935c6d64)

[分类、危害](https://thief.one/2017/05/31/1/)

[cookie格式](https://zhuanlan.zhihu.com/p/99916740)

[深入浅出cookie](https://www.jianshu.com/p/66c6f0c0ec82)

[cookie](https://thinkjs.org/zh-cn/doc/3.0/cookie.html)

XSS(cross-site scripting)跨站脚本攻击。攻击者提交恶意脚本，未经过滤，嵌入到html页面中被执行

危害有：篡改网页代码、利用网页重定向、窃取cookie等

为了防范攻击者劫持cookie，可以在服务器的http响应头中给 ```Set-Cookie```  添加

```httponly```属性，禁止 javascript 脚本来访问 cookie

```secure```属性，告诉浏览器仅在请求为 https 的时候发送 cookie



### cookie 和 session

[cookie](https://segmentfault.com/a/1190000004743454)

[session实现原理](COOKIE和SESSION有什么区别？ - 任云肖的回答 - 知乎 https://www.zhihu.com/question/19786827/answer/151015728)

[详解cookie和session](https://www.cnblogs.com/zhouhbing/p/4204132.html)

因为http是无状态的协议，服务器不知道上一次的请求用户请求内容，所以用到cookie和session实现存储会话状态，来解决验证用户登录信息、跟踪用户行为等问题

cookie是存储在客户端的，只能存储字符串类型的数据，存储大小有限4kb，在http中明文传递安全性不高，有效期可以通过maxAge设置

session是存储在服务器端的比如文件、数据库、内存内，能存储各种类型的数据，存储大小数量没有限制但是数据量大会增加服务器的负担，以加密形式存储并在服务器上解密更安全，关于有效期服务器会把长时间内没有活跃的session从内存删除。

通常session的实现，需要借助cookie的sessionId。第一次创建session的时候，服务器发送响应告诉浏览器需要sessionId，浏览器每次的请求都带有sessionId值。（浏览器不支持cookie，可将sessionId值添加在url参数里）



### 一句话概括 RESTFUL

（restfull ，服务器与客户端交互的风格。为什么要用？为不同的客户端提供统一的接口）

**用 URL 定位资源， 用 HTTP 动作描述操作**





### 说一下web worker

html页面中，执行js脚本会阻塞页面，导致页面状态不可响应

web worker 是运行在后台的 js， 独立于其他脚本， 不会影响页面性能。并且通过 postMessage 将结果回传到主线程



## HTML

### 说一下 web Quality

无障碍，是指网站对那些残障人士来说是易用的

比如：

- img标签使用```alt```属性，浏览器可以显示或读出图片描述
- 正确使用语义化标签，适宜读屏软件阅读
- 字体大小使用相对尺寸，便于用户按需在浏览器中调整大小
- 留意颜色的对比



### 说一下 HTML5 drag api

事件主体是被拖放元素：

- dragstart：开始拖放时触发
- drag：正在拖放时触发
- dragend：拖放操作结束时触发

事件主体是目标元素：

- dragenter：被拖放元素进入目标元素时触发
- dragover：被拖放元素在目标元素中移动时触发
- dragleave：被拖放元素移出目标元素时触发
- drop：目标元素完全接受被拖放元素时触发

拖拽事件有dataTransfer属性，用来存储拖动数据。可以通过setData、getData来操作



### 对 HTML 语义化标签的理解

[HTML语义化](https://juejin.im/post/5ae029bcf265da0b7155f15d#comment)

语义化标签能让人立马看出表达的内容，比如nav标签表示导航条

虽然一个页面仅靠div、span标签就可以构造

但是用语义标签的好处是，页面结构清晰增强代码的可读性，还有利于机器阅读对残障人士是易用的，



###  iframe 是什么？ 有什么缺点

**用iframe标签来创建包含另一个文档的内联框架**，每个iframe形成自己的窗口

**缺点：**

- **会阻塞主页面onload事件**
- **搜索引擎无法解读这种页面， 不利于 SEO**
- **浏览器限制了同一域名下的并发请求数量，iframe和主页面共享连接池，iframe加载资源占用了可用连接，阻塞了主页面资源请求加载**
- **移动设备无法完全显示框架，设备兼容性差**

(①现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。②如果需要使用iframe，最好是通过js动态给iframe添加src属性值，这样可以绕开以上1.3问题)



### Doctype 作用? 严格模式与混杂模式如何区分？ 它们有何意义

[总资料](https://www.cnblogs.com/wuqiutong/p/5986191.html)

[html5](https://www.w3school.com.cn/tags/tag_doctype.asp)

[DTD](https://www.w3school.com.cn/dtd/index.asp)

Doctype声明在html文档最前面，告诉浏览器以何种方式渲染页面

区分：不声明Doctype，或者

严格模式：排版和js运行模式，都以浏览器支持的最高标准运行

混杂模式：排版和js运行模式，不严格按照严格标准执行，主要为了向后兼容，兼容旧的浏览器

(```<!DOCTYPE html>```：按html5标准解析页面，HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别)





### iframe 通信，同源和不同源两种情况

[比较全的参考资料](https://developer.51cto.com/art/201906/598311.htm)

- 同源：
  - 直接获取对方的window对象，子页面获取父页面通过```window.parent```获取父页面的，父页面通过```iframe的名字.window```或```document.getElementById('').contentWindow```获取子页面的window对象，然后就可以访问对方的方法、变量了
  - 通过localStorage。一个页面更新localStorage，就会触发storage事件，另一个页面监听storage就能获得消息
  - 共享线程SharedWorker
  - BroadCast Channel   [参考](https://www.cnblogs.com/tutuj/p/11023063.html)



[深入理解前端跨域方法和原理](https://www.cnblogs.com/daodaowei/p/5877954.html)

- 不同源：
  - 利用html5新特性：window.postMessage  
  
    [ 目标窗口.postMessage(msg,目标源)  &  window.addEventListener('message', function(){}, false) ]
  
  - 两个窗口一级域名相同，只是二级域名不同，那么设置页面的document.domain属性为相同，即可跨域获取DOM
  
  - 通过window.name共享数据，子页面将数据赋值给window.name，当iframe加载完成后，设置iframe的src是当前父页面域的一个页面，就可以访问iframe的window.name了  [document.domain/window.name](https://www.cnblogs.com/alsy/p/5470772.html)







### ❤❤❤如何画一个三角形











## 浏览器

### 几个很实用的 BOM 属性对象方法

BOM，浏览器对象模型，描述了浏览器对象的层级关系

- window：最顶层的对象，其他对象都是他的属性
  - 弹窗类方法：alert、confirm、prompt
  - 定时器类方法：setInterval、setTimeout
  - sessionStorage、localStorage
  - ......
- document：文档对象
- location：浏览器当前url信息
  - location.href：返回或设置当前页面的url
  - location.search：返回包括？在内的查询字符串部分
  - location.hash：返回#后面的内容
  - location.host：返回url的域名部分（www.baidu.com）
  - location.hostname：返回url的主域名部分（baidu.com）
  - location.pathname：返回url的域名后面的部分（www.baidu.com/question?title=1 => /question?title=1）
  - location.port：返回url的端口部分
  - location.protocol：返回url中的协议部分 （http、https...）
  - location.assign(url)：加载url指定的新html文档。可以返回上一页
  - location.replace(url)：加载url指定的新文档替换当前文档。history对象的地址列表删除当前url，无法返回上一页
  - location.reload()：重载当前页面
- navigator：浏览器本身信息
  - navigator.cookieEnabled：返回浏览器是否启用cookie
  - navigator.userAgent：返回由客户端发送给服务器端的user-agent头部信息，包括appCodeName、appVersion
- screen：浏览器屏幕信息
  - height：屏幕总高度
  
  - availHeight：除去任务栏(电脑桌面的任务栏)后屏幕总高度
  
    height、availHeight和浏览器放大缩小没有关系
- history：浏览器访问历史信息
  - history.go(num|url)：加载history列表中的某个具体的页面
  - history.back()：后退一页
  - history.forward()：前进一页





### 讲讲 viewport 和移动端布局

[相对长度绝对长度](https://juejin.im/post/5cceb946e51d453afb40d820#comment)

[特别好的文章](https://juejin.im/post/5cddf289f265da038f77696c#heading-2)

广义的视口就是浏览器显示内容的区域，狭义的视口有布局视口、视觉视口和理想视口三种。

布局视口，是浏览器绘制网页内容的区域，顶级元素html的大小就是基于它的。在pc端，大小就是浏览器窗口的大小；在移动端，屏幕缩小，为了让网页内容不缩成一块，默认布局视口大小是980px

视觉视口，在该设备下当前可见的区域，对浏览器缩放可以调整视觉视口大小，比如缩小到50%，css像素变小，但是看到的网页的范围变大也就是视觉视口变大

理想视口，通过980px的布局视口将内容搬运到移动端效果还是不好，出现了理想的布局视口，也就是设备独立像素的大小。在viewport元标签中设置width=device-width，初始缩放比例initial-scale=1.0就可以了



为了页面能在移动端适配，需要结合一些方法来实现移动端布局：

[布局方法1](https://segmentfault.com/a/1190000010412860)

[布局方法2](https://juejin.im/post/5a8c12935188257a6049a0a4#heading-12)

- 媒体查询

  因为css文件中1px大小在不同设备中代表不同的物理像素，所以实际大小是不同的

  根据不同屏幕的大小， 编写多套样式， 从而达到自适应的效果

- 





### click 在 ios 上有 300ms 延迟， 原因及如何解决

[参考1](https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0#comment)

[参考2](https://zhuanlan.zhihu.com/p/28052894)

浏览器有个默认的双击缩放功能。当用户单击后，浏览器要等待300ms，确认不是双击后才触发click事件

浏览器双击缩放的功能主要为了提高以前那些未做移动端适配的网站体验的。而现在，只要写上viewpoint的meta标签，并设置布局视口宽度等于设备宽度，浏览器就会放弃双击缩放功能

还有利用fastclick库，检测到touchend事件后，立刻触发模拟的click事件，并且（调event.preventDefault）把浏览器300ms后真正将触发的click事件阻断

```javascript
// 引入库
...
// 纯js版
if('addEventListener' in document){
    document.addEventListener('DOMContentLoaded',function(){
        FastClick.attach(document.body);
    },false)
}
// jQuery版
$(function(){
    FastClick.attach(document.body);
})
```

css的touch-action属性设为none，（阻止浏览器的默认行为），不响应用户的触控操作



### addEventListener 参数

[介绍event相关概念](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events)

addEventListener(event, function, useCapture)

**event：事件名**	([事件列表](https://www.runoob.com/jsref/dom-obj-event.html)，写名称时去掉on)

**function：事件触发时要执行的函数**

**useCapture：可选，true代表捕获阶段执行，false代表冒泡阶段执行。默认是false**。

​				  		**新标准里面第三个参数可以是对象了**[新标准里的对象](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)

【比如触发了单击按钮事件，那按钮的父元素也被单击了，甚至整个页面都被单击了。所以出现了事件流的概念，即，从页面中接受事件的顺序。W3C规定的事件流有三个阶段，捕获阶段（事件消息从根节点被派遣到目标节点的父元素），目标阶段（目标节点接受事件消息），冒泡阶段（事件消息从目标节点传回根节点）】

[掘金参考](https://juejin.im/entry/5826ba9d0ce4630056f85e07) [事件委托](https://wordpress.diguage.com/archives/71.html)





### 强缓存/协商缓存

[github资料](http://louiszhai.github.io/2017/04/07/http-cache/)

[知乎资料❤特别全面](https://zhuanlan.zhihu.com/p/44789005)

- 强缓存：当缓存中含有浏览器请求的资源且没有过期时，则拦截请求，直接返回资源

  由字段Expires或者Cache-control里的max-age控制的，cache-control优先级高于expires

- 协商缓存：当强制缓存的资源过期时，请求服务器，由服务器决定缓存内容是否失效

  由两组字段控制：

  Last-Modified & If-Modified-Since  与 E-Tag & If-None-Match

  ①缓存区保存的响应资源有Last-Modified字段，存储该资源最后修改时间，

  该值付给请求头的If-Modified-Since字段，发送给服务器，

  与服务器最新资源的Last-Modified比较，如果等，表示未修改，响应状态码304，直接从缓存中取

  不同则响应状态码200，返回最新资源

  - 这样根据时间来判断资源是否修改不精确，比如文件是动态生成的，即使内容没变修改时间也变了，就不能缓存文件了。所以出现了Etag字段，存储的是资源版本的标志，能更精确缓存未修改的资源

    [Etag优点](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Etag)

  ②判断过程与上面类似





### 强缓存、 协商缓存什么时候用哪个

缓存内的资源没有过期，就用强缓存，直接从缓存中获取

缓存过期后，就用协商缓存，请求服务器，服务器上的资源更新了返回新的资源， 没有更新就从缓存中获取， 

以最大程度的减少因网络请求而产生的资源浪费







## 前端优化

