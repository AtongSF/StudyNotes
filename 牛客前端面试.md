[HTML5技术](https://www.techug.com/post/40-important-html-5-interview-questions-with-answers.html)

# 前端基础



## HTTP



### HTTP和HTTPS

- HTTP，超文本传输协议，用于服务器端传输超文本到浏览器端

- HTTPS，在HTTP基础下加入了ssl层，确保了数据加密传输和身份认证，可以理解成HTTP的安全版

- HTTP和HTTPS对比：

  - HTTP传输的数据是未加密的明文；而HTTPS加入了SSL层，能进行身份验证、对传输的数据进行加密、使数据不被窃取改变保证完整性，更安全
  - 使用HTTPS的网站在搜索引擎上排名更高，而使用HTTP的网站可能会被标记为不安全
  - HTTP协议的端口是80；HTTPS协议的端口是443
  - 与HTTP相比，HTTPS需要ca证书，费用较高
  - HTTPS握手阶段比较费时， 会使页面加载时间延长
  - HTTPS缓存不如 HTTP高效， 会增加数据开销
  - SSL 证书需要绑定 IP， 不能再同一个 ip 上绑定多个域名， ipv4 资源支持不了这种消耗

- HTTPS工作原理：

  [参考资料：漫画聊HTTPS协议](https://zhuanlan.zhihu.com/p/57142784)

  [其他方法的不足](https://zhuanlan.zhihu.com/p/27395037)

  - 服务器端生成一对公钥和私钥，将公钥发给证书颁发机构

  - 证书机构用自己的私钥加密服务器端发送来的公钥，并利用服务端网址等信息生成证书签名，签名也经私钥加密。最后将证书发送给服务器端

  - 服务器端 直接发送给证书 客户端

  - 因为各大浏览器和操作系统有所有权威证书机构的名称和公钥，所以客户端可以根据机构名取出对应的机构公钥

  - 客户端先用公钥 解密出 证书签名，验证证书签名

  - 客户端再用机构公钥 解密 机构私钥，得到服务器端的公钥

  - 客户端对称生成密钥，用服务器端公钥加密该密钥，发送给服务器

  - 服务器端 用自己的私钥 解密 公钥，得到客户端的密钥，从此之后的数据传输就用该密钥加密解密

    （上述认证过程是在SSL层中完成的，现在的TSL是SSL的升级版）



### ❤❤❤介绍 HTTP 协议(特征)



### 说一下HTTP2.0

[一篇文章让你入门HTTP2](https://segmentfault.com/a/1190000016656529?utm_source=tag-newest)

- 多路复用

  允许通过一个http连接同时发送多个请求-响应消息，解决了浏览器限制同一个域名下的请求数量的问题

- 二进制分帧

  在应用层和传输层之间增加一个二进制分帧层，将传输信息分割成更小的帧，并进行二进制编码

- 首部压缩

  采用HPACK算法对首部进行编码，减少了首部大小（原来是文本形式的首部，加上cookie则更大）

- 服务器端推送

  服务器对客户端的一个请求发送多个响应（收到客户端的某个请求后主动推送其他资源）

- 更安全



### UDP和TCP区别

- TCP是面向连接的；UDP是无连接的
- TCP提供可靠的服务，通过TCP链接传送的数据，无差错、不丢失、不重复、按序到达；UDP不保证可靠交付
- TCP面向字节流；UDP面向字节流
- TCP只能一对一通信；UDP支持一对一，一对多
- TCP动态改变窗口的大小进行拥塞控制；UDP没有用塞控制(适合视频电话等需要源主机以恒定速率传输数据又允许丢包的应用)
- TCP首部最大20字节；UDP首部最大8字节



### TCP握手

[三次握手四次挥手](https://juejin.im/post/5b1d34eb6fb9a01e7d5c3e25#comment)

一句话概括：客户端和服务端都需要知道各自可收发， 因此需要三次握手

- 第一次握手(SYN=1，seqNum=X)：

  客户端发送一个SYN标志位置1的包，并产生随机的X放在序列号字段中，发起连接请求，等待服务器确认，进入```SYN_SEND```状态

- 第二次握手(SYN=1，ACK=1，seqNUm=Y，ackNum=X+1)：

  服务端发送一个SYN和ACK标志位都置1的确认包，（并将客户端序列号字段中的X+1存入确认号字段，随机产生Y存入序列号字段中），进入```SYN_RCVD```状态

- 第三次握手(ACK=1，ackNum=Y+1)

  客户端发送一个ACK标志位置1的确认包，并将服务端的序列号Y+1存入确认号字段中，进入```ESTABLISHED```状态

  当服务端接收到确认包后，握手结束，建立了TCP连接



### WebSocket的实现与应用

（一些概念：无状态、短连接、长连接、轮询、长轮询、http keep-alive、tcp keep-alive 心跳包  [参考资料1](WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎 https://www.zhihu.com/question/20215561/answer/40316953)  [参考资料2](https://juejin.im/post/5b10b822e51d4506cd4fc218 )）

WebSocket的特点是，服务器能主动发送数据给客户端，还有持久连接

实现：

①

握手建立连接的过程，与http协议差不多，只是请求头和响应头多了一些内容。

请求头的：

```Upgrade: websocket``` 和 ```Connection: Upgrade``` 告诉服务端发起的是websocket请求

```Sec-WebSocket-Key``` 是客户端随机生成的一个密钥 ，要求服务端必须返回一个对应加密的```Sec-WebSocket-Accept```应答

```Sec-WebSocket-Version```告诉服务器所使用的 Websocket 协议版本响应头的

响应头的：

```Upgrade: websocket``` 和 ```Connection: Upgrade``` 告诉客户端即将升级的是WebSocket协议（返回状态吗101）

② [websocket数据传输原理](https://cloud.tencent.com/developer/article/1194146 )  [websocket-protocol书](https://github.com/zhangkaitao/websocket-protocol)

数据传输以数据帧为单位，发送端将消息切割成多个帧发送，当标志位FIN=1时，表示是消息的最后一个分片，接收端将帧重组成消息，根据opCode标志位来对消息进行不同操作



### ❤❤❤HTTP请求方式

[请求报文格式](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html)

- http1.0：get、post、head
- http1.1：put、options、trace、delete、connection
- http2.0：patch



### GET 和 POST 的区别

[知乎详解](https://www.zhihu.com/question/28586791)

GET和POST作为协议的内容没有本质区别，只是规定了不同语义(性质)，GET用来获取资源，POST用来提交数据

但是浏览器对他们有具体的实现，所以GET、POST有不同的表现，在浏览器中：

- ①GET参数以查询字符串形式通过url传递，所以参数不能是敏感信息， ②有长度限制， ③参数只支持ASCII码，非ASCII字符(按utf-8方式)转成十六进制的字节数组，再用%分隔连接 [(编码解码资料)](https://segmentfault.com/a/1190000015800019)

  ①POST参数写在请求体中， ②没有长度限制， ③支持多种编码方式

- GET请求会保留在浏览记录里，能被收藏为书签，请求的结果会被缓存；POST请求不行（否则，第二次点击下单按钮就返回原来订单成功界面，点书签直接就下单）

- GET请求是幂等操作，相同的请求被执行多次也不会对服务器状态产生影响；POST请求是非幂等的

- （GET 产生一个 TCP 数据包； POST 产生两个 TCP 数据包。即GET请求把http header和data一并发送出去；而POST请求先发送header，在发送data，但火狐浏览器不是这样的）



### 讲讲 304

表示资源未修改。客户端的请求的If-Modified-Since与服务器的Last-Modified字段值比对，如果相同，表示服务器上的资源未修改，只返回响应头，状态码是304，从缓存获得资源。一般发生在协商缓存的过程中	[304资料](https://blog.csdn.net/huwei2003/article/details/70139062)





### 补充 400 和 401、 403 状态码

400：客户端请求的语法错误，可能是提交数据的类型或名称与后台实体没有对应，或者没有将对象转化为json字符串

401：当前请求需要用户验证

403：服务器收到请求，但是拒绝执行





### 301 和 302 的区别

- 301，永久移动。①请求的资源被永久移动到新的url了，浏览器自动定向到新url	②会默认缓存返回的资源	③常用在域名跳转
- 302，临时移动。①资源只是临时被移动，之后的请求继续使用原来的url	②默认不会缓存返回的资源	③常用在页面临时跳转的时候，比如访问404页面重定向到首页，点击个人中心跳转到登录页





### 状态码 304 和 200

- 304
- 200，请求成功。服务器成功处理了请求，返回请求所希望的响应头或数据体





### ❤❤❤http 常用请求头



### 具体有哪些请求头是跟缓存相关的

[条件请求If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since](https://blog.csdn.net/jiangshangchunjiezi/article/details/88581824)

- expires
- cache-control
- if-modified-since    (if-unmodified-since?)
- if--none-match    (if-match?)
- if-range?



### ❤❤❤常见的 HTTP 的头部

给头部分个类，可以有请求头、响应头、通用头、实体头

- 请求头
- 响应头
- 通用头
- 是实体头



### cache-control 的值有哪些

cache-control的值是缓存指令，用来规定资源缓存方式、缓存位置和缓存期限

常见指令有：

no-cache：资源可以缓存，但是每次需要向服务器请求，验证后才能使用

no-store：彻底禁用缓存，每次都向浏览器请求资源

private：表明响应的资源只能由客户端缓存

public：响应的资源可以存在客户端、CDN等其他缓存中，能在用户间共享

max-age，资源缓存的有效期

（cache-control的重要性：能针对性处理公共资源、私密资源、常常更新的资源、静态资源）



### 一个图片 url 访问后直接下载怎样实现

设置响应头：

```json
'Content-Disposition':'attachment;filename=xxx',
'Content-Type':'content-type: application/octet-stream' // 告诉客户端这是一个二进制文件
```



### fetch 发送 2 次请求的原因

[HTTP访问控制（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)

[跨源请求](https://zh.javascript.info/fetch-crossorigin)

[预检](https://www.w3cways.com/2280.html)

[跨域资源共享 CORS 详解](https://www.ruanyifeng.com/blog/2016/04/cors.html)

[简单请求非简单请求](https://juejin.im/post/5d71d1e7f265da03934c027b#comment)

**是浏览器CORS机制造成的。**

**当该请求是非简单请求时，就会触发浏览器首先会发送一个options预检请求，验证是否是服务器对跨源请求所支持 HTTP 方法，如果支持则状态码是204（no content）**

**然后在第二次中发送真正的请求**

简单请求：（普通 HTML Form 在不依赖脚本的情况下可以发出的请求）

①GET、HEAD、POST	

②没有自定义头，请求头的字段只能有Content-Type、Content-Language、Accept、Accept-Language等	

③Content-Type只能是application/x-www-form-urlencoded, multipart/form-data, text/plain

非简单请求：可能会对服务器数据产生副作用



### Cookie、 sessionStorage、 localStorage

[XXS攻击](https://segmentfault.com/a/1190000016551188)

- Cookie：存在于http头中在服务器和浏览器之间来回传送，可以自己设置过期时间，存储容量小只有4KB

  保存登录状态、保存用户页面设置信息、跟踪用户的行为(所选地区)

- sessionStorage：保存在客户端不参与与服务器通信，仅在当前窗口关闭前有效(刷新页面不会消失)，存储容量有5MB

  编辑页面自动保存草稿功能

- localStorage：保存在客户端不参与与服务器通信，除非人为清除不然不会失效同源窗口都可以共享数据， 存储容量有5MB

  可以用来页面间传递参数
  
  

### Cookie 如何防范 XSS 攻击

[美团总结](https://juejin.im/post/5bad9140e51d450e935c6d64)

[分类、危害](https://thief.one/2017/05/31/1/)

[cookie格式](https://zhuanlan.zhihu.com/p/99916740)

[深入浅出cookie](https://www.jianshu.com/p/66c6f0c0ec82)

[cookie](https://thinkjs.org/zh-cn/doc/3.0/cookie.html)

XSS(cross-site scripting)跨站脚本攻击。攻击者提交恶意脚本，未经过滤，嵌入到html页面中被执行

危害有：篡改网页代码、利用网页重定向、窃取cookie等

为了防范攻击者劫持cookie，可以在服务器的http响应头中给 ```Set-Cookie```  添加

```httponly```属性，禁止 javascript 脚本来访问 cookie

```secure```属性，告诉浏览器仅在请求为 https 的时候发送 cookie



### cookie 和 session

[cookie](https://segmentfault.com/a/1190000004743454)

[session实现原理](COOKIE和SESSION有什么区别？ - 任云肖的回答 - 知乎 https://www.zhihu.com/question/19786827/answer/151015728)

[详解cookie和session](https://www.cnblogs.com/zhouhbing/p/4204132.html)

因为http是无状态的协议，服务器不知道上一次的请求用户请求内容，所以用到cookie和session实现存储会话状态，来解决验证用户登录信息、跟踪用户行为等问题

cookie是存储在客户端的，只能存储字符串类型的数据，存储大小有限4kb，在http中明文传递安全性不高，有效期可以通过maxAge设置

session是存储在服务器端的比如文件、数据库、内存内，能存储各种类型的数据，存储大小数量没有限制但是数据量大会增加服务器的负担，以加密形式存储并在服务器上解密更安全，关于有效期服务器会把长时间内没有活跃的session从内存删除。

通常session的实现，需要借助cookie的sessionId。第一次创建session的时候，服务器发送响应告诉浏览器需要sessionId，浏览器每次的请求都带有sessionId值。（浏览器不支持cookie，可将sessionId值添加在url参数里）



###  ❤❤❤cookie 有哪些字段可以设置



### ❤❤❤cookie 有哪些编码方式





### 一句话概括 RESTFUL

（restfull ，服务器与客户端交互的风格。为什么要用？为不同的客户端提供统一的接口）

**用 URL 定位资源， 用 HTTP 动作描述操作**





### 说一下web worker

html页面中，执行js脚本会阻塞页面，导致页面状态不可响应

web worker 是运行在后台的 js， 独立于其他脚本， 不会影响页面性能。并且通过 postMessage 将结果回传到主线程



## HTML

### 说一下 web Quality

无障碍，是指网站对那些残障人士来说是易用的

比如：

- img标签使用```alt```属性，浏览器可以显示或读出图片描述
- 正确使用语义化标签，适宜读屏软件阅读
- 字体大小使用相对尺寸，便于用户按需在浏览器中调整大小
- 留意颜色的对比



### 说一下 HTML5 drag api

事件主体是被拖放元素：

- dragstart：开始拖放时触发
- drag：正在拖放时触发
- dragend：拖放操作结束时触发

事件主体是目标元素：

- dragenter：被拖放元素进入目标元素时触发
- dragover：被拖放元素在目标元素中移动时触发
- dragleave：被拖放元素移出目标元素时触发
- drop：目标元素完全接受被拖放元素时触发

拖拽事件有dataTransfer属性，用来存储拖动数据。可以通过setData、getData来操作



### 对 HTML 语义化标签的理解

[HTML语义化](https://juejin.im/post/5ae029bcf265da0b7155f15d#comment)

语义化标签能让人立马看出表达的内容，比如nav标签表示导航条

虽然一个页面仅靠div、span标签就可以构造

但是用语义标签的好处是，页面结构清晰增强代码的可读性，还有利于机器阅读对残障人士是易用的，



###  iframe 是什么？ 有什么缺点

**用iframe标签来创建包含另一个文档的内联框架**，每个iframe形成自己的窗口

**缺点：**

- **会阻塞主页面onload事件**
- **搜索引擎无法解读这种页面， 不利于 SEO**
- **浏览器限制了同一域名下的并发请求数量，iframe和主页面共享连接池，iframe加载资源占用了可用连接，阻塞了主页面资源请求加载**
- **移动设备无法完全显示框架，设备兼容性差**

(①现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。②如果需要使用iframe，最好是通过js动态给iframe添加src属性值，这样可以绕开以上1.3问题)



### Doctype 作用? 严格模式与混杂模式如何区分？ 它们有何意义

[总资料](https://www.cnblogs.com/wuqiutong/p/5986191.html)

[html5](https://www.w3school.com.cn/tags/tag_doctype.asp)

[DTD](https://www.w3school.com.cn/dtd/index.asp)

Doctype声明在html文档最前面，告诉浏览器以何种方式渲染页面

区分：不声明Doctype，或者

严格模式：排版和js运行模式，都以浏览器支持的最高标准运行

混杂模式：排版和js运行模式，不严格按照严格标准执行，主要为了向后兼容，兼容旧的浏览器

(```<!DOCTYPE html>```：按html5标准解析页面，HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别)





### iframe 通信，同源和不同源两种情况

[比较全的参考资料](https://developer.51cto.com/art/201906/598311.htm)

- 同源：
  - 直接获取对方的window对象，子页面获取父页面通过```window.parent```获取父页面的，父页面通过```iframe的名字.window```或```document.getElementById('').contentWindow```获取子页面的window对象，然后就可以访问对方的方法、变量了
  - 通过localStorage。一个页面更新localStorage，就会触发storage事件，另一个页面监听storage就能获得消息
  - 共享线程SharedWorker
  - BroadCast Channel   [参考](https://www.cnblogs.com/tutuj/p/11023063.html)



[深入理解前端跨域方法和原理](https://www.cnblogs.com/daodaowei/p/5877954.html)

- 不同源：
  - 利用html5新特性：window.postMessage  
  
    [ 目标窗口.postMessage(msg,目标源)  &  window.addEventListener('message', function(){}, false) ]
  
  - 两个窗口一级域名相同，只是二级域名不同，那么设置页面的document.domain属性为相同，即可跨域获取DOM
  
  - 通过window.name共享数据，子页面将数据赋值给window.name，当iframe加载完成后，设置iframe的src是当前父页面域的一个页面，就可以访问iframe的window.name了  [document.domain/window.name](https://www.cnblogs.com/alsy/p/5470772.html)







### 如何画一个三角形

利用边框均分的原理

假如想要一个底边20px、高10px的白色等腰三角形

将div的宽度、高度都设为0

左右上边框属性都设置为10px solid transparent

下边框属性10px solid white

- 可以调整其余三个边框的border-width的值来改变三角形的大小形状



### HTML5 新增的元素

增加了语义标签，如header、footer、nav等

表单方面，增加了新标签datalist、keygen、output；input有了新的输入类型，比如color、email、range、search，还有新的属性autocomplete、height、width、placeholder等

多媒体方面，规定了audio、vedio元素

图形方面，新增了canvas绘图、支持内联svg

提供了许多API，比如地理定位、web worker、拖放、存储方面的sessionStorage、localStorage和离线存储([离线存储](https://segmentfault.com/a/1190000000732617))便于在客户端存取数据

还有新增了web socket协议



### ❤❤❤HTML5 和 CSS3 用的多吗？ 你了解它们的新属性吗？ 有在项目中用过吗？





## 浏览器

### 几个很实用的 BOM 属性对象方法

BOM，浏览器对象模型，描述了浏览器对象的层级关系

- window：最顶层的对象，其他对象都是他的属性
  - 弹窗类方法：alert、confirm、prompt
  - 定时器类方法：setInterval、setTimeout
  - sessionStorage、localStorage
  - ......
- document：文档对象
- location：浏览器当前url信息
  - location.href：返回或设置当前页面的url
  - location.search：返回包括？在内的查询字符串部分
  - location.hash：返回#后面的内容
  - location.host：返回url的域名部分（www.baidu.com）
  - location.hostname：返回url的主域名部分（baidu.com）
  - location.pathname：返回url的域名后面的部分（www.baidu.com/question?title=1 => /question?title=1）
  - location.port：返回url的端口部分
  - location.protocol：返回url中的协议部分 （http、https...）
  - location.assign(url)：加载url指定的新html文档。可以返回上一页
  - location.replace(url)：加载url指定的新文档替换当前文档。history对象的地址列表删除当前url，无法返回上一页
  - location.reload()：重载当前页面
- navigator：浏览器本身信息
  - navigator.cookieEnabled：返回浏览器是否启用cookie
  - navigator.userAgent：返回由客户端发送给服务器端的user-agent头部信息，包括appCodeName、appVersion
- screen：浏览器屏幕信息
  - height：屏幕总高度
  
  - availHeight：除去任务栏(电脑桌面的任务栏)后屏幕总高度
  
    height、availHeight和浏览器放大缩小没有关系
- history：浏览器访问历史信息
  - history.go(num|url)：加载history列表中的某个具体的页面
  - history.back()：后退一页
  - history.forward()：前进一页





### 讲讲 viewport 和移动端布局

[相对长度绝对长度](https://juejin.im/post/5cceb946e51d453afb40d820#comment)

[特别好的文章](https://juejin.im/post/5cddf289f265da038f77696c#heading-2)

广义的视口就是浏览器显示内容的区域，狭义的视口有布局视口、视觉视口和理想视口三种。

布局视口，是浏览器绘制网页内容的区域，顶级元素html的大小就是基于它的。在pc端，大小就是浏览器窗口的大小；在移动端，屏幕缩小，为了让网页内容不缩成一块，默认布局视口大小是980px

视觉视口，在该设备下当前可见的区域，对浏览器缩放可以调整视觉视口大小，比如缩小到50%，css像素变小，但是看到的网页的范围变大也就是视觉视口变大

理想视口，通过980px的布局视口将内容搬运到移动端效果还是不好，出现了理想的布局视口，也就是设备独立像素的大小。在viewport元标签中设置width=device-width，初始缩放比例initial-scale=1.0就可以了



为了页面能在移动端适配，需要结合一些方法来实现移动端布局：

[布局方法1](https://segmentfault.com/a/1190000010412860)

[布局方法2](https://juejin.im/post/5a8c12935188257a6049a0a4#heading-12)

- 媒体查询

  因为css文件中1px大小在不同设备中代表不同的物理像素，所以实际大小是不同的

  根据不同屏幕的大小， 编写多套样式， 从而达到自适应的效果

- 





### click 在 ios 上有 300ms 延迟， 原因及如何解决

[参考1](https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0#comment)

[参考2](https://zhuanlan.zhihu.com/p/28052894)

浏览器有个默认的双击缩放功能。当用户单击后，浏览器要等待300ms，确认不是双击后才触发click事件

浏览器双击缩放的功能主要为了提高以前那些未做移动端适配的网站体验的。而现在，只要写上viewpoint的meta标签，并设置布局视口宽度等于设备宽度，浏览器就会放弃双击缩放功能

还有利用fastclick库，检测到touchend事件后，立刻触发模拟的click事件，并且（调event.preventDefault）把浏览器300ms后真正将触发的click事件阻断

```javascript
// 引入库
...
// 纯js版
if('addEventListener' in document){
    document.addEventListener('DOMContentLoaded',function(){
        FastClick.attach(document.body);
    },false)
}
// jQuery版
$(function(){
    FastClick.attach(document.body);
})
```

css的touch-action属性设为none，（阻止浏览器的默认行为），不响应用户的触控操作



### addEventListener 参数

[介绍event相关概念](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events)

addEventListener(event, function, useCapture)

**event：事件名**	([事件列表](https://www.runoob.com/jsref/dom-obj-event.html)，写名称时去掉on)

**function：事件触发时要执行的函数**

**useCapture：可选，true代表捕获阶段执行，false代表冒泡阶段执行。默认是false**。

​				  		**新标准里面第三个参数可以是对象了**[新标准里的对象](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)

【比如触发了单击按钮事件，那按钮的父元素也被单击了，甚至整个页面都被单击了。所以出现了事件流的概念，即，从页面中接受事件的顺序。W3C规定的事件流有三个阶段，捕获阶段（事件消息从根节点被派遣到目标节点的父元素），目标阶段（目标节点接受事件消息），冒泡阶段（事件消息从目标节点传回根节点）】

[掘金参考](https://juejin.im/entry/5826ba9d0ce4630056f85e07) [事件委托](https://wordpress.diguage.com/archives/71.html)





### 强缓存/协商缓存

[github资料](http://louiszhai.github.io/2017/04/07/http-cache/)

[知乎资料❤特别全面](https://zhuanlan.zhihu.com/p/44789005)

- 强缓存：当缓存中含有浏览器请求的资源且没有过期时，则拦截请求，直接返回资源

  由字段Expires或者Cache-control里的max-age控制的，cache-control优先级高于expires

- 协商缓存：当强制缓存的资源过期时，请求服务器，由服务器决定缓存内容是否失效

  由两组字段控制：

  Last-Modified & If-Modified-Since  与 E-Tag & If-None-Match

  ①缓存区保存的响应资源有Last-Modified字段，存储该资源最后修改时间，

  该值付给请求头的If-Modified-Since字段，发送给服务器，

  与服务器最新资源的Last-Modified比较，如果等，表示未修改，响应状态码304，直接从缓存中取

  不同则响应状态码200，返回最新资源

  - 这样根据时间来判断资源是否修改不精确，比如文件是动态生成的，即使内容没变修改时间也变了，就不能缓存文件了。所以出现了Etag字段，存储的是资源版本的标志，能更精确缓存未修改的资源

    [Etag优点](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Etag)

  ②判断过程与上面类似





### 强缓存、 协商缓存什么时候用哪个

缓存内的资源没有过期，就用强缓存，直接从缓存中获取

缓存过期后，就用协商缓存，请求服务器，服务器上的资源更新了返回新的资源， 没有更新就从缓存中获取， 

以最大程度的减少因网络请求而产生的资源浪费



### 浏览器在生成页面的时候， 会生成那两颗树

DOM树 和 CSSOM规则树

浏览器的渲染引擎，解析HTML生成DOM树，解析CSS生成CSSOM规则树，

将DOM树与CSSOM规则树合并在一起生成渲染树

遍历渲染树，计算每个节点的位置大小信息，开始布局

将渲染树每个节点绘制到屏幕上（由浏览器的UI后端组件绘制）





### ❤❤❤在地址栏里输入一个 URL,到这个页面呈现出来， 中间会发生什么



### ❤❤❤浏览器输入网址到页面渲染全过程





### ❤❤❤csrf 和 xss 的网络攻击及防范



## ❤❤❤前端优化



## ❤❤❤怎么看网站的性能如何





## CSS





## JavaScript



### 说一下闭包

闭包就是持久的局部变量作用域 [stackoverflow](https://stackoverflow.com/questions/36636/what-is-a-closure) [知乎讲解原理](https://www.zhihu.com/question/19554716/answer/146795877) [scope属性里的Closure](https://juejin.im/post/5c08ef8ef265da616301dd01#comment) [详细执行过程](https://segmentfault.com/a/1190000018001871)

常用的形式是在一个函数内部在声明一个子函数并返回子函数，调用该函数后，调用子函数还能访问到作用域内的值

闭包的原理涉及到执行上下文和scope属性。子函数执行前的预编译阶段产生scope属性，引用了父函数执行产生的执行上下文 ；执行时，产生自身的执行上下文，依次引用scope属性的值和活动对象。因为父函数的执行上下文一直被引用着，内存空间没有被销毁，所以局部变量一直可以访问。 [详细原理](https://blog.csdn.net/q1056843325/article/details/53086893#commentBox)

(具体过程：假如一个父函数A，其内部声明的子函数是B。A预编译，产生scope属性并创建活动对象；A执行时产生执行上下文，引用了scope属性的值和活动对象；子函数B预编译时，同样产生scope属性和活动对象，scope属性引用父函数A执行产生的执行上下文。当B执行时，产生的执行上下文，又引用scope属性的值和活动对象。)

闭包的常见应用场景，外围的父函数作为函数工厂来新建函数，作为事件处理程序(event handler)[event](https://stackoverflow.com/questions/2622421/what-are-the-use-cases-for-closures-callback-functions-in-javascript)，模拟私有方法的功能   [私有化方法](https://medium.com/@dis_is_patrick/practical-uses-for-closures-c65640ae7304)

(缺点：内存消耗大，可以在外部修改父函数内部的值)

(优点：保存作用域，外部可访问)



### 说一下类的创建和继承

[网道js教程-对象的继承](https://wangdoc.com/javascript/oop/prototype.html#prototype-%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8)

[github解答](https://github.com/creeperyang/blog/issues/9#)

[掘金](https://juejin.im/post/5c72a1766fb9a049ea3993e6#heading-5)

[JavaScript 世界万物诞生记](https://zhuanlan.zhihu.com/p/22989691)

JavaScript的对象是基于原型的，但是为了迎合主流的用类描述对象，加了一些语言特性模拟类

**类的创建：**

- ES6之前，类是通过构造函数和原型对象来创建的：声明一个构造函数，然后给他的prototype对象定义实例能共享的属性、方法

- es6中增加新特性class(实际上是对原型继承的封装  [封装](https://segmentfault.com/a/1190000017842257))：声明方式是class+类名，成员变量最好写在构造器里，括号加大括号表示方法

  ```javascript
  class Person{
      constructor(name){
          this.name = name;
      }
      smile(){}
  }
  ```

  

**类的继承**：

- 构造继承：子类的构造函数里调用call方法，使用父类的构造函数来增强子类实例， 等于是复制父类的实例属性给子类

  优点：能够多继承

  缺点：没有用到原型，无法继承原型对象的属性方法；子类的实例不是父类的实例

  ```javascript
  function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
  }
  ```

- 基于原型链的继承：new一个父类对象，赋值给子类的prototype

  优点：能获得原型对象的属性方法；子类的实例也是父类的实例

  缺点：不能多继承，子类只能获得一个父类的功能

  ```javascript
  function Cat(){}
  Cat.prototype = new Animal()
  ```

  





### ❤❤❤如何解决异步回调地狱

- Promise

  把嵌套的回调改成链式的回调

- generator

  

- async/await





### js 的 new 操作符做了哪些事情

1. 新建一个空的新对象
2. 将构造函数的 ```prototype``` 原型对象赋值给新对象的 ```__proto__``` 属性
3. 改变构造函数中的this指向，改成指向新对象
4. 执行构造函数
5. 返回这个新对象





### 改变函数内部 this 指针的指向函数（ bind， apply， call 的区别）

三个函数的意义就是：改变函数运行时的this指向

第一个参数作为新函数的this指向，其余的参数作为新函数的参数

- bind：

  一个函数调用bind改变this指向后，返回一个新的函数，并不立马执行
  
- call 和 apply 

  都是改变函数的this指向后，就执行这个函数

  但是apply的参数形式与bind、call不同，除了第一个对象参数外，剩余的参数写在一个数组中





### 深浅拷贝的区别和实现

浅拷贝，只是保存着指向对象的引用

深拷贝，完全拷贝，保存的是与原对象一模一样的新对象，不共用内存空间

- 浅拷贝的实现
  
- 数组的slice、contact方法
  
  - ```javascript
    let shallowCopy = function(obj){
        if(typeof obj != 'object'){
            return;
        }
        let newObject = obj instanceof Array ? [] : {};
        for(let key in obj){
            if(obj.hasOwnProperty(key)){
                newObj[key] = obj[key];
            }
        }
        return newObject;
    }
    ```
  
- 深拷贝的实现
  
  - JSON.parse(JSON.stringfy(obj))
  
  - ```javascript
    // 判断值的类型，递归调用深拷贝函数
    let deepCopy = function(obj){
        if(typeof obj != 'object'){
            return;
        }
        let newObject = obj instanceof Array ? [] : {};
        for(let key in obj){
            if(obj.hasOwnProperty(key)){
                newObject[key]  = typeof obj[key] == 'object' ? deepCopy(obj[key]) : obj[key];
            }
        }
        return newObject;
    }
    ```
  
    

